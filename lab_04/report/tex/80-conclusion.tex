\StructuredChapter{Ответы на контрольные вопросы}

\textbf{1. Преимущества и недостатки XDMA и QDMA платформ}

%Преимущества использовани XDMA:
%\begin{itemize}
%	\item Проще работать
%\end{itemize}

Недостатки использовани XDMA:
\begin{enumerate}
	\item Большая латентность и меньшая пропускная способность за счет того, что данные сначало должны быть перемещены в память ускорителя.
\end{enumerate}

Преимущества использования QDMA:
\begin{enumerate}
	\item Предоставляет прямое потоковое соединение с низкой задержкой и большой пропускной способностью между хостом и ядрами;
	\item Позволяет передавать поток данных непосредственно в логику FPGA параллельно с их обработкой.
\end{enumerate}

%Недостатки использования QDMA:
%\begin{itemize}
%	\item Требуется организовать очередь на хост-устройстве.
%\end{itemize}

\textbf{2. Последовательность действий, необходимых для инициализации ускорителя со стороны хост-системы}

\begin{enumerate}
	\item С помощью вызова clGetPlatformIDs хост получает все платформы.
	\item С помощью вызова clGetPlatformInfo хост получает имя платформы и затем выбирает  платформу Xilinx.
	\item С помощью вызова clGetDeviceIDs хост получает ID устройства.
	\item С помощью вызова clGetDeviceInfo хост получает информацию об устройстве.
	\item С помощью вызова clCreateContext создается контекст для переменных.
	\item С помощью вызова clCreateCommandQueue создается команда для устройтво-ускорителя.
\end{enumerate}

\textbf{3. Процедура запуска задания на исполнения в ускорительном ядре VINC}

\begin{enumerate}
	\item С помощью вызова load\_file\_to\_memory данные, бинарный поток (данные из *.xclbin), копируются из ОЗУ в локальную память ускорителя посредством DMA.
	\item По итогу выполнения clCreateProgramWithBinary, clBuildProgram и clCreateKernel  создается исполняемый файл (уже в памяти устройства-ускорителя).
	\item С помощью clCreateBuffer и clEnqueueWriteBuffer данные, подлежащие обработке, копируются из ОЗУ в локальную память ускорителя посредством DMA (с помощью второй команды осуществляется передача указателей на начало буферов исходных операндов).
	\item С помощью двух вызовов clSetKernelArg указываются параметры (в данном случае это d\_scalar00 и d\_axi00\_ptr0).
	\item С помощью команды clEnqueueNDRangeKernel запускается исполнение ядра (программы на ускорителе).
	\item С помощью команды clEnqueueReadBuffer выполняется чтение готовых данных.
\end{enumerate}

\textbf{4. Процесс линковки на основании содержимого log-файла}

Процесс сборки состоит из шести этапов.
\begin{enumerate}
	\item Анализ конфигурационного файла, анализ профиля устройства, поиск необходимых аппаратных компонентов, интерфейсов;
	\item FPGA линковка синтезированных ядер с платформой;
	\item FPGA оптимизация логики (минимизация логики (булевой) для оптимизации площади, минимизации задержек);
	\item FPGA logic placement (Преобразование булевых уравнений в схему логики ПЛИС. Выбор конкретного места для каждого логического блока в ПЛИС);
	\item FPGA разводка (создание соединений между логическими блоками);
	\item FPGA генерирование файла с программной информацией для отправки его на ПЛИС (*.xclbin файл);
\end{enumerate}
